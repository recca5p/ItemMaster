name: CI/CD Lambda (.NET 8)

on:
  workflow_dispatch: { }
  push:
    tags:
      - 'v*.*.*'
  pull_request:
    branches:
      - master

env:
  AWS_REGION: ap-southeast-1
  LAMBDA_FUNCTION_NAME: im-dev-lambda-item-master
  PROJECT_PATH: ItemMaster.Lambda
  OUTPUT_DIR: out
  MYSQL_SECRET_ID: ${{ secrets.RDS_SECRET_ID }}

permissions:
  id-token: write
  contents: read

jobs:
  build-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-dotnet@v4
        with: { dotnet-version: '8.x' }
      - run: dotnet restore
      - run: dotnet build --configuration Release --no-restore
      - name: Run tests with coverage
        run: dotnet test --configuration Release --no-build --logger "trx;LogFileName=test-results.trx" --collect:"XPlat Code Coverage" --results-directory ./coverage --settings coverage.runsettings
      
      - name: Generate coverage report
        if: always()
        run: |
          if [ -d ./coverage ]; then
            echo "Coverage reports generated:"
            ls -la ./coverage/**/
          fi
      
      - name: Install ReportGenerator
        if: always()
        run: dotnet tool install -g dotnet-reportgenerator-globaltool
      
      - name: Generate HTML coverage report
        if: always()
        run: |
          REPORT_OUTPUT="./coverage-html"
          reportgenerator \
            -reports:"./coverage/**/coverage.cobertura.xml" \
            -targetdir:"${REPORT_OUTPUT}" \
            -reporttypes:"Html;Badges;JsonSummary" \
            -classfilters:"-Microsoft.*;-System.*;-xunit.*" \
            -verbosity:Warning
          echo "Coverage HTML report generated in ${REPORT_OUTPUT}"
      
      - name: Upload test results and coverage
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results-and-coverage
          path: |
            test-results.trx
            coverage/
            coverage-html/
          retention-days: 30
          

      - name: Publish (linux-arm64)
        run: |
          dotnet publish -c Release -r linux-arm64 --self-contained false -o $OUTPUT_DIR ./ItemMaster.Lambda/src/ItemMaster.Lambda
          cd $OUTPUT_DIR && zip -r ../function.zip . && cd -
      - uses: actions/upload-artifact@v4
        with: { name: lambda-package, path: function.zip }

  deploy:
    needs: build-test
    runs-on: ubuntu-latest
    # Only deploy on push to main, tags, or manual trigger (not on PRs)
    if: github.event_name != 'pull_request'
    steps:
      - uses: actions/checkout@v4

      - uses: actions/download-artifact@v4
        with: { name: lambda-package, path: . }
        
      - uses: actions/download-artifact@v4
        with: { name: test-results-and-coverage, path: ./test-results }

      - name: Configure AWS creds
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Determine deployment type
        id: deploy-type
        run: |
          if [[ "${{ github.ref }}" == refs/tags/v*.*.* ]]; then
            echo "type=tag" >> $GITHUB_OUTPUT
            echo "version=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT
            echo "Deploying tagged version: ${GITHUB_REF#refs/tags/}"
          elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "type=manual" >> $GITHUB_OUTPUT
            echo "version=manual-$(date +%Y%m%d-%H%M%S)" >> $GITHUB_OUTPUT
            echo "Manual deployment triggered"
          else
            echo "type=push" >> $GITHUB_OUTPUT
            echo "version=main-$(date +%Y%m%d-%H%M%S)" >> $GITHUB_OUTPUT
            echo "Deploying from main branch"
          fi

      - name: Update Lambda code
        run: |
          aws lambda update-function-code \
            --function-name "$LAMBDA_FUNCTION_NAME" \
            --zip-file fileb://function.zip \
            --publish
          aws lambda wait function-updated --function-name "$LAMBDA_FUNCTION_NAME"

      - name: Tag Lambda version
        if: steps.deploy-type.outputs.type == 'tag'
        run: |
          VERSION="${{ steps.deploy-type.outputs.version }}"
          FUNCTION_VERSION=$(aws lambda list-versions-by-function \
            --function-name "$LAMBDA_FUNCTION_NAME" \
            --query 'Versions[-1].Version' \
            --output text)
          
          aws lambda tag-resource \
            --resource "arn:aws:lambda:${AWS_REGION}:$(aws sts get-caller-identity --query Account --output text):function:${LAMBDA_FUNCTION_NAME}:${FUNCTION_VERSION}" \
            --tags "Version=${VERSION},DeployedAt=$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          
          echo "Tagged Lambda version $FUNCTION_VERSION with $VERSION"

      - name: Health Check
        run: |
          echo "Performing health check on deployed Lambda..."
          
          # Create health check payload
          echo '{}' > /tmp/health-payload.json
          
          # Invoke Lambda for health check
          INVOKE_RESULT=$(aws lambda invoke \
            --function-name "$LAMBDA_FUNCTION_NAME" \
            --payload fileb:///tmp/health-payload.json \
            --cli-binary-format raw-in-base64-out \
            /tmp/health-response.json 2>&1)
          
          INVOKE_EXIT_CODE=$?
          
          echo "Health check invoke result:"
          echo "$INVOKE_RESULT"
          
          if [ $INVOKE_EXIT_CODE -eq 0 ]; then
            echo "Lambda invocation successful"
          
            # Check response content
            if [ -f /tmp/health-response.json ]; then
              echo "ðŸ“„ Response content:"
              cat /tmp/health-response.json
          
              # Parse status code from response
              STATUS_CODE=$(cat /tmp/health-response.json | jq -r '.statusCode // empty' 2>/dev/null || echo "")
          
              if [ "$STATUS_CODE" = "200" ]; then
                echo "âœ… Health check passed - Lambda is healthy (Status: 200)"
              else
                echo "âš ï¸  Health check warning - Unexpected status code: $STATUS_CODE"
                # Don't fail the deployment for non-200 status as Lambda might still be functional
              fi
            else
              echo "âŒ No response file found"
              exit 1
            fi
          else
            echo "âŒ Health check failed"
            exit 1
          fi
          
          # Show recent logs for debugging
          echo "ðŸ“Š Recent Lambda logs (last 5 minutes):"
          aws logs tail "/aws/lambda/${LAMBDA_FUNCTION_NAME}" --since 5m --format short || true

      - name: Create deployment summary
        if: always()
        run: |
          echo "## ðŸš€ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Function**: \`$LAMBDA_FUNCTION_NAME\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Region**: \`$AWS_REGION\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Deployment Type**: \`${{ steps.deploy-type.outputs.type }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Version**: \`${{ steps.deploy-type.outputs.version }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Trigger**: \`${{ github.event_name }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Actor**: @${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Ref**: \`${{ github.ref }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [[ "${{ steps.deploy-type.outputs.type }}" == "tag" ]]; then
            echo "ðŸ·ï¸ **Tagged Release Deployment**" >> $GITHUB_STEP_SUMMARY
          elif [[ "${{ steps.deploy-type.outputs.type }}" == "manual" ]]; then
            echo "ðŸ‘¤ **Manual Deployment**" >> $GITHUB_STEP_SUMMARY
          else
            echo "ðŸ”„ **Automatic Deployment from main**" >> $GITHUB_STEP_SUMMARY
          fi

  pr-comment:
    needs: build-test
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    permissions:
      pull-requests: write
    steps:
      - uses: actions/download-artifact@v4
        with: { name: test-results-and-coverage, path: ./test-results }
      
      - name: Generate coverage summary
        id: coverage
        run: |
          COVERAGE_XML=$(find ./test-results -name "coverage.cobertura.xml" | head -1)
          
          if [ -n "$COVERAGE_XML" ] && [ -f "$COVERAGE_XML" ]; then
            # Extract coverage percentage from cobertura XML
            LINE_RATE=$(grep -o 'line-rate="[0-9.]*"' "$COVERAGE_XML" | grep -o '[0-9.]*' | head -1 || echo "0")
            PERCENTAGE=$(awk "BEGIN {printf \"%.1f\", $LINE_RATE * 100}")
            
            echo "coverage=$PERCENTAGE" >> $GITHUB_OUTPUT
            echo "Coverage: $PERCENTAGE%"
          else
            echo "coverage=N/A" >> $GITHUB_OUTPUT
            echo "Coverage report not found"
          fi
      
      - name: Comment on PR
        uses: actions/github-script@v7
        with:
          script: |
            const coverage = '${{ steps.coverage.outputs.coverage }}';
            const coverageValue = parseFloat(coverage);
            const isNumeric = !isNaN(coverageValue);
            const coverageBadge = !isNumeric ? 'âšª' : coverageValue >= 90 ? 'ðŸŸ¢' : coverageValue >= 75 ? 'ðŸŸ¡' : coverageValue >= 50 ? 'ðŸŸ ' : 'ðŸ”´';
            
            const message = `## âœ… Build & Test Successful
            
            The Lambda package has been built and tested successfully for this PR.
            
            ${coverageBadge} **Code Coverage**: ${isNumeric ? coverage + '%' : coverage}
            
            ðŸ“Š Coverage reports are available in the workflow artifacts.
            
            **Note**: Deployment is skipped for pull requests. Merge to \`main\` or create a tag \`v*.*.*\` to deploy.
            
            ### Next Steps:
            - Review the code changes
            - Merge to \`main\` for automatic deployment
            - Or create a release tag (e.g., \`v1.2.3\`) for versioned deployment
            `;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: message
            });
